/* eslint-disable no-console */
import type { ClientConfig, ServerConfig } from '@site/src/types';
import * as cloudflareKVAssetHandler from '@cloudflare/kv-asset-handler';
import * as ittyRouter from 'itty-router';
// @ts-ignore - TS doesn't know about the __STATIC_CONTENT_MANIFEST import
import assetManifestJSON from '__STATIC_CONTENT_MANIFEST';

export interface Env extends ServerConfig {
  // CF Worker Sites automatically injects this to point to the KV namespace
  __STATIC_CONTENT: KVNamespace<string>;
}

const router = ittyRouter.Router();

/**
 * Map request to documentation asset (HTML, CSS, JS, images, files... etc)
 * This worker is routed from `polykey.com/docs`
 * All of the `../docs` assets is uploaded to the "root" of the worker
 * Therefore the `/docs` path segment must be removed, as `getAssetFromKV` uses the pathname
 * of the URL to look up the correct asset
 */
function mapRequestToDocs(req: Request): Request {
  // This will map `/x` to `/x/index.html`, if `/x` does not exist.
  // This is conventional for HTTP servers.
  const assetRequest = cloudflareKVAssetHandler.mapRequestToAsset(req);
  const assetUrl = new URL(assetRequest.url);
  // Strip the `/docs` segment: `https://polykey.com/docs/...` -> `https://polykey.com/...`
  assetUrl.pathname = assetUrl.pathname.replace(/^\/docs/, '/');
  return new Request(assetUrl.toString(), assetRequest);
}

router.all('*', async (req: Request, env: Env, ctx: ExecutionContext) => {
  const reqURL = new URL(req.url);
  const cacheControl = {
    edgeTTL: 2 * 24 * 60 * 60,
    bypassCache: env.POLYKEY_DOCS_ENV === 'development' ? true : false,
  };
  const url = new URL(req.url);
  // Check if the URL pathname is exactly '/docs'
  if (url.pathname === '/docs') {
    console.log('Redirecting /docs to /docs/');
    return Response.redirect(url.origin + '/docs/', 301);
  }
  // This is a mapping from request paths to content-hashed keys generated by
  // wrangler as a cache busting measure.
  const assetManifest = JSON.parse(assetManifestJSON);
  let response: Response;
  try {
    response = await cloudflareKVAssetHandler.getAssetFromKV(
      {
        request: req,
        waitUntil: ctx.waitUntil.bind(ctx),
      },
      {
        // This will map `/x` to `/x/index.html`, if `/x` does not exist.
        // This is conventional for HTTP servers.
        mapRequestToAsset: mapRequestToDocs,
        cacheControl,
        ASSET_NAMESPACE: env.__STATIC_CONTENT,
        ASSET_MANIFEST: assetManifest,
      },
    );
    if (reqURL.pathname.startsWith('/assets')) {
      response.headers.set('Cache-Control', 'max-age=31536000, immutable');
    } else {
      response.headers.set('Cache-Control', 'max-age=86400');
    }
  } catch (e) {
    if (e instanceof cloudflareKVAssetHandler.NotFoundError) {
      console.log('Requested resource not found', e.message);
      const response404 = await cloudflareKVAssetHandler.getAssetFromKV(
        {
          request: req,
          waitUntil: ctx.waitUntil.bind(ctx),
        },
        {
          mapRequestToAsset: (req: Request) => {
            // Map request to 404.html page.
            return new Request(`${new URL(req.url).origin}/404.html`, req);
          },
          cacheControl,
          ASSET_NAMESPACE: env.__STATIC_CONTENT,
          ASSET_MANIFEST: assetManifest,
        },
      );
      const headers = new Headers(response404.headers);
      headers.set('Cache-Control', 'max-age=86400');
      response = new Response(response404.body, {
        ...response404,
        headers,
        status: 404,
      });
    } else if (e instanceof cloudflareKVAssetHandler.MethodNotAllowedError) {
      response = new Response('Method Not Allowed', { status: 405 });
    } else {
      response = new Response('Server Error', { status: 500 });
    }
  }
  if (
    !['/assets', '/files', '/images', '/fonts'].some((path) =>
      reqURL.pathname.startsWith(path),
    )
  ) {
    if (response.headers.get('Content-Type')?.includes('text/html')) {
      const config: ClientConfig = {
        POLYKEY_DOCS_ENV: env.POLYKEY_DOCS_ENV,
      };
      response = new HTMLRewriter()
        .on('head', {
          element(element) {
            element.prepend(
              `<script>globalThis.config = ${JSON.stringify(config)};</script>`,
              { html: true },
            );
          },
        })
        .transform(response);
    }
  }
  return response;
});

const worker = {
  async fetch(req: Request, env: Env, ctx: ExecutionContext) {
    console.log('Handling request from', req.url);
    return router.handle(req, env, ctx);
  },
};

export default worker;
